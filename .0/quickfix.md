- So give &Arc<Mutex<Vec<Result<Whatever>>>> to every SubQuery, (and now this is what's called Query). And then provide SubQueries to the manager, defined on the provider. And they all can be handled the same way now, as every query is a self-contained runtime and some additional args to wrap it in rate-limit-aware matter
- SubQuery now has `percent_completed` field that has to be updated by the query's runtime. (when singular, update from 0 to 1). SubQuery has `estimated_time_left_s` also. It could be first set by the scheduler function of the provider. But mainly it is updated by the manager of the provider, which checks Option<timestamp_ms: u64>, (changed from None, when query's runtime is started), field on the SubQuery, with %completed in mind, time to time.
- SubQueries are immediately attached to the least busy Client on the Provider by .add_sub_query. Moved later if needed by the Manager.The only physical place where they are ever stored is according Vecs on Clients
